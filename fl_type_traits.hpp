/*
    Boost Software License - Version 1.0 - August 17th, 2003

    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:

    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

// See https://github.com/Ail-nare/fl-Lib for library's documentation and updates

#ifndef FLLIB_FL_TYPE_TRAITS_HPP
#define FLLIB_FL_TYPE_TRAITS_HPP

#include <type_traits>

namespace /* This namespace is there to hide the macros */ {
#if __cplusplus >= 202002L // For the future C++ 20
#define IF_CXX_MORE_EQ_20(...) __VA_ARGS__
#define IF_CXX_20(...) __VA_ARGS__
#define IF_CXX_LESS_20(...)
#define IF_CXX_MORE_EQ_17(...) __VA_ARGS__
#define IF_CXX_17(...)
#define IF_CXX_LESS_17(...)
#define IF_CXX_MORE_EQ_14(...) __VA_ARGS__
#define IF_CXX_14(...)
#define IF_CXX_LESS_14(...)
#define IF_CXX_MORE_EQ_11(...) __VA_ARGS__
#define IF_CXX_11(...)
#define IF_CXX_LESS_11(...)
#elif  __cplusplus >= 201703L // if (current_version >= C++17)
#define IF_CXX_MORE_EQ_20(...)
#define IF_CXX_20(...)
#define IF_CXX_LESS_20(...) __VA_ARGS__
#define IF_CXX_MORE_EQ_17(...) __VA_ARGS__
#define IF_CXX_17(...) __VA_ARGS__
#define IF_CXX_LESS_17(...)
#define IF_CXX_MORE_EQ_14(...) __VA_ARGS__
#define IF_CXX_14(...)
#define IF_CXX_LESS_14(...)
#define IF_CXX_MORE_EQ_11(...) __VA_ARGS__
#define IF_CXX_11(...)
#define IF_CXX_LESS_11(...)
#elif __cplusplus >= 201402L // if (current_version >= C++14)
#define IF_CXX_MORE_EQ_20(...)
#define IF_CXX_20(...)
#define IF_CXX_LESS_20(...) __VA_ARGS__
#define IF_CXX_MORE_EQ_17(...)
#define IF_CXX_17(...)
#define IF_CXX_LESS_17(...) __VA_ARGS__
#define IF_CXX_MORE_EQ_14(...) __VA_ARGS__
#define IF_CXX_14(...) __VA_ARGS__
#define IF_CXX_LESS_14(...)
#define IF_CXX_MORE_EQ_11(...) __VA_ARGS__
#define IF_CXX_11(...)
#define IF_CXX_LESS_11(...)
#elif __cplusplus >= 201103L // if (current_version >= C++11)
#define IF_CXX_MORE_EQ_20(...)
#define IF_CXX_20(...)
#define IF_CXX_LESS_20(...) __VA_ARGS__
#define IF_CXX_MORE_EQ_17(...)
#define IF_CXX_17(...)
#define IF_CXX_LESS_17(...) __VA_ARGS__
#define IF_CXX_MORE_EQ_14(...)
#define IF_CXX_14(...)
#define IF_CXX_LESS_14(...) __VA_ARGS__
#define IF_CXX_MORE_EQ_11(...) __VA_ARGS__
#define IF_CXX_11(...) __VA_ARGS__
#define IF_CXX_LESS_11(...)
#else  // if (current_version < C++11)
#define IF_CXX_MORE_EQ_20(...)
#define IF_CXX_20(...)
#define IF_CXX_LESS_20(...) __VA_ARGS__
#define IF_CXX_MORE_EQ_17(...)
#define IF_CXX_17(...)
#define IF_CXX_LESS_17(...) __VA_ARGS__
#define IF_CXX_MORE_EQ_14(...)
#define IF_CXX_14(...)
#define IF_CXX_LESS_14(...) __VA_ARGS__
#define IF_CXX_MORE_EQ_11(...)
#define IF_CXX_11(...)
#define IF_CXX_LESS_11(...) __VA_ARGS__
#endif

#if defined(_MSC_VER)
#define WARNING_PUSH __pragma(warning(push))
#define WARNING_POP __pragma(warning(pop))
#define WARNING_DISABLE(name, code) __pragma(warning( disable : code ))
#elif defined(__GNUC__) || defined(__clang__)
#define DO_PRAGMA(X) _Pragma(#X)
#define WARNING_PUSH DO_PRAGMA(GCC diagnostic push)
#define WARNING_POP DO_PRAGMA(GCC diagnostic pop)
#define WARNING_DISABLE(name, code) DO_PRAGMA(GCC diagnostic ignored #name)
#else
#define WARNING_PUSH
#define WARNING_POP
#define WARNING_DISABLE(name, code)
#endif

#define FL_EVALUATE(macro, ...) macro(__VA_ARGS__)
}

namespace fl {
    struct true_type;
    struct false_type;

    template <typename T>
    struct std_to_fl {
        typedef typename std::conditional<
            std::is_same<std::true_type, T>::value,
            fl::true_type,
            typename std::conditional<
                std::is_same<std::false_type, T>::value,
                fl::false_type,
                T
            >::type
        >::type type;
    };
    IF_CXX_MORE_EQ_11(template <typename T> using std_to_fl_t = typename std_to_fl<T>::type);

    namespace is /* std::<type_traits> "std::true_type/false_type -> fl::true_type/false_type" */ {
        namespace /* This namespace is there to hide the macro */ {
        #if  __cplusplus >= 201703L // if (current_version >= C++17)
        #define FL_CONVERT_STD_BOOL_1ARGS(std_name, fl_name)                                                                            \
            template <typename T>                                                                                                       \
            struct [[maybe_unused]] fl_name : std::conditional<std::std_name<T>::value, fl::true_type, fl::false_type>::type {};        \
            template <typename T> [[maybe_unused]] constexpr inline bool fl_name##_v = fl_name<T>::value
        #define FL_CONVERT_STD_BOOL_2ARGS(std_name, fl_name)                                                                            \
            template <typename T1, typename T2>                                                                                         \
            struct [[maybe_unused]] fl_name : std::conditional<std::std_name<T1, T2>::value, fl::true_type, fl::false_type>::type {};   \
            template <typename T1, typename T2> [[maybe_unused]] inline constexpr bool fl_name##_v = fl_name<T1, T2>::value
        #define FL_CONVERT_STD_BOOL_1ARGS_VA_ARGS(std_name, fl_name)                                                                    \
            template <typename T, typename ...Ts>                                                                                       \
            struct [[maybe_unused]] fl_name : std::conditional<std::std_name<T, Ts...>::value, fl::true_type, fl::false_type>::type {}; \
            template <typename T, typename ...Ts> [[maybe_unused]] inline constexpr bool fl_name##_v = fl_name<T, Ts...>::value
        #define FL_CONVERT_STD_BOOL_2ARGS_VA_ARGS(std_name, fl_name)                                                                                \
            template <typename T1, typename T2, typename ...Ts>                                                                                     \
            struct [[maybe_unused]] fl_name : std::conditional<std::std_name<T1, T2, Ts...>::value, fl::true_type, fl::false_type>::type {};        \
            template <typename T1, typename T2, typename ...Ts> [[maybe_unused]] inline constexpr bool fl_name##_v = fl_name<T1, T2, Ts...>::value
        #else
        #define FL_CONVERT_STD_BOOL_1ARGS(std_name, fl_name)                                                                    \
            template <typename T>                                                                                               \
            struct [[maybe_unused]] fl_name : std::conditional<std::std_name<T>::value, fl::true_type, fl::false_type>::type {}
        #define FL_CONVERT_STD_BOOL_2ARGS(std_name, fl_name)                                                                        \
            template <typename T1, typename T2>                                                                                     \
            struct [[maybe_unused]] fl_name : std::conditional<std::std_name<T1, T2>::value, fl::true_type, fl::false_type>::type {}
        #define FL_CONVERT_STD_BOOL_1ARGS_VA_ARGS(std_name, fl_name)                                                                    \
            template <typename T, typename ...Ts>                                                                                       \
            struct [[maybe_unused]] fl_name : std::conditional<std::std_name<T, Ts...>::value, fl::true_type, fl::false_type>::type {}
        #define FL_CONVERT_STD_BOOL_2ARGS_VA_ARGS(std_name, fl_name)                                                                        \
            template <typename T1, typename T2, typename ...Ts>                                                                             \
            struct [[maybe_unused]] fl_name : std::conditional<std::std_name<T1, T2, Ts...>::value, fl::true_type, fl::false_type>::type {}
        #endif
        }

        namespace /* Primary type categories */ {
            FL_CONVERT_STD_BOOL_1ARGS(is_void, _void);
            IF_CXX_LESS_14(
                template<typename T>
                struct _null_pointer : std::conditional<std::is_same<std::nullptr_t, typename std::remove_cv<T>::type>::value, fl::true_type, fl::false_type>::type {}
            );
            IF_CXX_MORE_EQ_14(FL_CONVERT_STD_BOOL_1ARGS(is_null_pointer, _null_pointer));
            FL_CONVERT_STD_BOOL_1ARGS(is_integral, _integral);
            FL_CONVERT_STD_BOOL_1ARGS(is_floating_point, _floating_point);
            FL_CONVERT_STD_BOOL_1ARGS(is_array, _array);
            FL_CONVERT_STD_BOOL_1ARGS(is_enum, _enum);
            FL_CONVERT_STD_BOOL_1ARGS(is_union, _union);
            FL_CONVERT_STD_BOOL_1ARGS(is_class, _class);
            FL_CONVERT_STD_BOOL_1ARGS(is_pointer, _pointer);
            FL_CONVERT_STD_BOOL_1ARGS(is_lvalue_reference, _lvalue_reference);
            FL_CONVERT_STD_BOOL_1ARGS(is_rvalue_reference, _rvalue_reference);
            FL_CONVERT_STD_BOOL_1ARGS(is_member_object_pointer, _member_object_pointer);
            FL_CONVERT_STD_BOOL_1ARGS(is_member_function_pointer, _member_function_pointer);
        }
        namespace /* Composite type categories */ {
            FL_CONVERT_STD_BOOL_1ARGS(is_fundamental, _fundamental);
            FL_CONVERT_STD_BOOL_1ARGS(is_arithmetic, _arithmetic);
            FL_CONVERT_STD_BOOL_1ARGS(is_scalar, _scalar);
            FL_CONVERT_STD_BOOL_1ARGS(is_object, _object);
            FL_CONVERT_STD_BOOL_1ARGS(is_compound, _compound);
            FL_CONVERT_STD_BOOL_1ARGS(is_reference, _reference);
            FL_CONVERT_STD_BOOL_1ARGS(is_member_pointer, _member_pointer);
        }
        namespace /* Type properties */ {
            FL_CONVERT_STD_BOOL_1ARGS(is_const, _const);
            FL_CONVERT_STD_BOOL_1ARGS(is_volatile, _volatile);
            FL_CONVERT_STD_BOOL_1ARGS(is_trivial, _trivial);
            FL_CONVERT_STD_BOOL_1ARGS(is_trivially_copyable, _trivially_copyable);
            FL_CONVERT_STD_BOOL_1ARGS(is_standard_layout, _standard_layout);
            IF_CXX_LESS_20(FL_CONVERT_STD_BOOL_1ARGS(is_pod, _pod));
            WARNING_PUSH WARNING_DISABLE(-Wdeprecated-declarations, 4973)
            IF_CXX_MORE_EQ_20(
                template <typename T>
                struct [[deprecated]] [[maybe_unused]] _pod : std::conditional<std::is_pod<T>::value, fl::true_type, fl::false_type>::type {};
                template <typename T> [[deprecated]] [[maybe_unused]] inline constexpr bool _pod_v = _pod<T>::value;
            ) WARNING_POP
            IF_CXX_LESS_17(FL_CONVERT_STD_BOOL_1ARGS(is_literal_type, _literal_type));
            WARNING_PUSH WARNING_DISABLE(-Wdeprecated-declarations, 4973)
            IF_CXX_17(
                template <typename T>
                struct [[deprecated]] [[maybe_unused]] _literal_type : std::conditional<std::is_pod<T>::value, fl::true_type, fl::false_type>::type {};
                template <typename T> [[deprecated]] [[maybe_unused]] inline constexpr bool _literal_type_v = _literal_type<T>::value;
            ) WARNING_POP
            IF_CXX_MORE_EQ_17(FL_CONVERT_STD_BOOL_1ARGS(has_unique_object_representations, has_unique_object_representations));
            FL_CONVERT_STD_BOOL_1ARGS(is_polymorphic, _polymorphic);
            FL_CONVERT_STD_BOOL_1ARGS(is_abstract, _abstract);
            IF_CXX_MORE_EQ_14(FL_CONVERT_STD_BOOL_1ARGS(is_final, _final));
            IF_CXX_MORE_EQ_17(FL_CONVERT_STD_BOOL_1ARGS(is_aggregate, _aggregate));
            FL_CONVERT_STD_BOOL_1ARGS(is_signed, _signed);
            FL_CONVERT_STD_BOOL_1ARGS(is_unsigned, _unsigned);
            IF_CXX_MORE_EQ_20(
                FL_CONVERT_STD_BOOL_1ARGS(is_bounded_array, _bounded_array);
                FL_CONVERT_STD_BOOL_1ARGS(is_unbounded_array, _unbounded_array);
            )
        }
        namespace /* Supported operations */ {
            FL_CONVERT_STD_BOOL_1ARGS_VA_ARGS(is_constructible, _constructible);
            FL_CONVERT_STD_BOOL_1ARGS_VA_ARGS(is_trivially_constructible, _trivially_constructible);
            FL_CONVERT_STD_BOOL_1ARGS_VA_ARGS(is_nothrow_constructible, _nothrow_constructible);

            FL_CONVERT_STD_BOOL_1ARGS(is_default_constructible, _default_constructible);
            FL_CONVERT_STD_BOOL_1ARGS(is_trivially_default_constructible, _trivially_default_constructible);
            FL_CONVERT_STD_BOOL_1ARGS(is_nothrow_default_constructible, _nothrow_default_constructible);

            FL_CONVERT_STD_BOOL_1ARGS(is_copy_constructible, _copy_constructible);
            FL_CONVERT_STD_BOOL_1ARGS(is_trivially_copy_constructible, _trivially_copy_constructible);
            FL_CONVERT_STD_BOOL_1ARGS(is_nothrow_copy_constructible, _nothrow_copy_constructible);

            FL_CONVERT_STD_BOOL_1ARGS(is_move_constructible, _move_constructible);
            FL_CONVERT_STD_BOOL_1ARGS(is_trivially_move_constructible, _trivially_move_constructible);
            FL_CONVERT_STD_BOOL_1ARGS(is_nothrow_move_constructible, _nothrow_move_constructible);

            FL_CONVERT_STD_BOOL_2ARGS(is_assignable, _assignable);
            FL_CONVERT_STD_BOOL_2ARGS(is_trivially_assignable, _trivially_assignable);
            FL_CONVERT_STD_BOOL_2ARGS(is_nothrow_assignable, _nothrow_assignable);

            FL_CONVERT_STD_BOOL_1ARGS(is_copy_assignable, _copy_assignable);
            FL_CONVERT_STD_BOOL_1ARGS(is_trivially_copy_assignable, _trivially_copy_assignable);
            FL_CONVERT_STD_BOOL_1ARGS(is_nothrow_copy_assignable, _nothrow_copy_assignable);

            FL_CONVERT_STD_BOOL_1ARGS(is_move_assignable, _move_assignable);
            FL_CONVERT_STD_BOOL_1ARGS(is_trivially_move_assignable, _trivially_move_assignable);
            FL_CONVERT_STD_BOOL_1ARGS(is_nothrow_move_assignable, _nothrow_move_assignable);

            FL_CONVERT_STD_BOOL_1ARGS(is_destructible, _destructible);
            FL_CONVERT_STD_BOOL_1ARGS(is_trivially_destructible, _trivially_destructible);
            FL_CONVERT_STD_BOOL_1ARGS(is_nothrow_destructible, _nothrow_destructible);

            FL_CONVERT_STD_BOOL_1ARGS(has_virtual_destructor, has_virtual_destructor);

            IF_CXX_MORE_EQ_17(
                FL_CONVERT_STD_BOOL_2ARGS(is_swappable_with, _swappable_with);
                FL_CONVERT_STD_BOOL_1ARGS(is_swappable, _swappable);
                FL_CONVERT_STD_BOOL_2ARGS(is_nothrow_swappable_with, _nothrow_swappable_with);
                FL_CONVERT_STD_BOOL_1ARGS(is_nothrow_swappable, _nothrow_swappable);
            )
        }
        namespace /* Property queries */ {
            template <typename T> using alignment_of = std::alignment_of<T>;
            IF_CXX_MORE_EQ_17(template <typename T> inline constexpr size_t alignment_of_v = alignment_of<T>::value);
            template <typename T> using rank = std::rank<T>;
            IF_CXX_MORE_EQ_17(template <typename T> inline constexpr size_t rank_v = rank<T>::value);
            template <typename T, unsigned N=0> using extent = std::extent<T, N>;
            IF_CXX_MORE_EQ_17(template <typename T, unsigned N=0> inline constexpr size_t extent_v = extent<T, N>::value);
        }
        namespace /* Type relationships */ {
            FL_CONVERT_STD_BOOL_2ARGS(is_same, _same);
            FL_CONVERT_STD_BOOL_2ARGS(is_base_of, _base_of);
            FL_CONVERT_STD_BOOL_2ARGS(is_convertible, _convertible);
            IF_CXX_MORE_EQ_20(
                FL_CONVERT_STD_BOOL_2ARGS(is_nothrow_convertible, _nothrow_convertible);
                FL_CONVERT_STD_BOOL_2ARGS(is_layout_compatible, is_layout_compatible);
                FL_CONVERT_STD_BOOL_2ARGS(is_pointer_interconvertible_base_of, _pointer_interconvertible_base_of);
            )
            IF_CXX_MORE_EQ_17(
                FL_CONVERT_STD_BOOL_1ARGS_VA_ARGS(is_invocable, _invocable);
                FL_CONVERT_STD_BOOL_2ARGS_VA_ARGS(is_invocable_r, _invocable_r);
                FL_CONVERT_STD_BOOL_1ARGS_VA_ARGS(is_nothrow_invocable, _nothrow_invocable);
                FL_CONVERT_STD_BOOL_2ARGS_VA_ARGS(is_nothrow_invocable_r, _nothrow_invocable_r);
            )
        }
        /* Maybe Useless */ namespace /* Const-volatility specifiers */ {}
        /* Maybe Useless */ namespace /* References */ {}
        /* Maybe Useless */ namespace /* Pointers */ {}
        /* Maybe Useless */ namespace /* Sign modifiers */ {}
        /* Maybe Useless */ namespace /* Arrays */ {}
        /* Maybe Useless */ namespace /* Miscellaneous transformations */ {}
        namespace /* Operations on traits */ {
            template<typename...> struct [[maybe_unused]] conjunction : fl::true_type {};
            template<typename T> struct [[maybe_unused]] conjunction<T> : std_to_fl<T>::type {};
            template<typename T, typename ...Ts>
            struct [[maybe_unused]] conjunction<T, Ts...> : std::conditional<bool(T::value), conjunction<Ts...>, typename std_to_fl<T>::type>::type {};
            IF_CXX_MORE_EQ_11(template<typename ...Ts> using conjunction_t = typename conjunction<Ts...>::type);
            IF_CXX_MORE_EQ_17(template<typename ...Ts> [[maybe_unused]] inline constexpr bool conjunction_v = conjunction<Ts...>::value);

            template<typename...> struct [[maybe_unused]] disjunction : fl::true_type {};
            template<typename T> struct [[maybe_unused]] disjunction<T> : std_to_fl<T>::type {};
            template<typename T, typename ...Ts>
            struct [[maybe_unused]] disjunction<T, Ts...> : std::conditional<!bool(T::value), disjunction<Ts...>, typename std_to_fl<T>::type>::type {};
            IF_CXX_MORE_EQ_11(template<typename ...Ts> using disjunction_t = typename disjunction<Ts...>::type);
            IF_CXX_MORE_EQ_17(template<typename ...Ts> [[maybe_unused]] inline constexpr bool disjunction_v = disjunction<Ts...>::value);

            template<class T>
            struct [[maybe_unused]] negation : std::conditional<bool(T::value), fl::false_type, fl::true_type>::type {};
            IF_CXX_MORE_EQ_11(template<typename T> using negation_t = typename negation<T>::type);
            IF_CXX_MORE_EQ_17(template<typename T> [[maybe_unused]] inline constexpr bool negation_v = negation<T>::value);
        }

        namespace /* This namespace is there to hide the macro */ {
        #undef FL_CONVERT_STD_FL_1ARGS
        #undef FL_CONVERT_STD_BOOL_2ARGS
        #undef FL_CONVERT_STD_BOOL_1ARGS_VA_ARGS
        #undef FL_CONVERT_STD_BOOL_2ARGS_VA_ARGS
        }
    }
}

namespace /* This namespace is there to hide the macro */ {
#undef IF_CXX_MORE_EQ_20
#undef IF_CXX_20
#undef IF_CXX_LESS_20
#undef IF_CXX_MORE_EQ_17
#undef IF_CXX_17
#undef IF_CXX_LESS_17
#undef IF_CXX_MORE_EQ_14
#undef IF_CXX_14
#undef IF_CXX_LESS_14

#undef FL_EVALUATE

#ifdef DO_PRAGMA
#undef DO_PRAGMA
#endif
#undef WARNING_PUSH
#undef WARNING_POP
#undef WARNING_DISABLE
}

#endif //FLLIB_FL_TYPE_TRAITS_HPP
