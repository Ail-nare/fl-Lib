/*
    Boost Software License - Version 1.0 - August 17th, 2003

    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:

    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

// See https://github.com/Ail-nare/fl-Lib for library's documentation and updates

#ifndef FLLIB_FL_H
#define FLLIB_FL_H

#include <type_traits>
#include <iostream>
#include <vector>
#include <string>
#include <tuple>

namespace fl {
    struct none {
        [[maybe_unused]] typedef none type;
    };
    struct undefined {};

    template <typename T>
    struct redirect {
        [[maybe_unused]] typedef T type;
    };
    template <typename T>
    struct [[maybe_unused]] redirect_type : redirect<typename T::type> {};
    template <typename T>
    struct [[maybe_unused]] redirect_value {
        [[maybe_unused]] static constexpr auto value = T::value;
        [[maybe_unused]] typedef decltype(T::value) value_type;
    };

    class true_type;
    class false_type;

    class true_type {
    public:
        [[maybe_unused]] constexpr static bool const value = true;
        [[maybe_unused]] typedef bool value_type;

        template <typename T1, typename T2>
        [[maybe_unused]] constexpr static T1 &returnValue(T1&& v, T2&&)
        { return v; }

        template <typename F, typename ...Ts>
        [[maybe_unused]] constexpr static auto func(F&& function, Ts&&... args) -> decltype(function(args...))
        { return function(args...); }

        template <typename F, typename N, typename ...Ts>
        [[maybe_unused]] constexpr static auto func_else(F&& function, N&&, Ts&&... args) -> decltype(function(args...))
        { return function(args...); }

        template <typename T, typename>
        struct [[maybe_unused]] conditional : redirect<T> {};
        template <typename T1, typename T2>
        using conditional_t = typename conditional<T1, T2>::type;

        template <typename T=void>
        struct [[maybe_unused]] enable_if : redirect<T> {};
        template <typename T=void>
        using enable_if_t = typename enable_if<T>::type;

        template <bool b>
        using And_b = typename std::conditional<b, fl::true_type, fl::false_type>::type;
        template <bool>
        using Or_b = fl::true_type;
        template <bool b>
        using Xor_b = typename std::conditional<b, fl::false_type, fl::true_type>::type;

        template <typename T>
        using And = And_b<bool(T::value)>;
        template <typename T>
        using Or = Or_b<bool(T::value)>;
        template <typename T>
        using Xor = Xor_b<bool(T::value)>;
        using Not = fl::false_type;

        constexpr operator bool() const noexcept { return value; }
    };
    class false_type {
    public:
        [[maybe_unused]] constexpr static bool const value = false;
        [[maybe_unused]] typedef bool value_type;

        template <typename T1, typename T2>
        [[maybe_unused]] constexpr static T2 &return_value(T1&&, T2&& v)
        { return v; }

        template <typename ...Ts>
        [[maybe_unused]] constexpr static void func(Ts&&...) {}

        template <typename N, typename F, typename ...Ts>
        [[maybe_unused]] constexpr static auto func_else(N&&, F&& function, Ts&&... args) -> decltype(function(args...))
        { return function(args...); }

        template <typename, typename T>
        struct [[maybe_unused]] conditional : redirect<T> {};
        template <typename T1, typename T2>
        using conditional_t = typename conditional<T1, T2>::type;

        template <typename T=void>
        struct [[maybe_unused]] enable_if {};
        template <typename T=void>
        using enable_if_t = typename enable_if<T>::type;


        template <bool>
        using And_b = fl::false_type;
        template <bool b>
        using Or_b = typename std::conditional<b, fl::true_type, fl::false_type>::type;
        template <bool b>
        using Xor_b = typename std::conditional<b, fl::true_type, fl::false_type>::type;

        template <typename T>
        using And = And_b<bool(T::value)>;
        template <typename T>
        using Or = Or_b<bool(T::value)>;
        template <typename T>
        using Xor = Xor_b<bool(T::value)>;
        using Not = fl::true_type;

        constexpr operator bool() const noexcept { return value; }
    };


    /// Convert a bool into ether fl::true_type or fl::false_type
    template <bool b>
    struct Bool : redirect_type<std::conditional<b, fl::true_type, fl::false_type>> {};
    template <bool b>
    using Bool_t = typename Bool<b>::type;

    template <typename T>
    using bTp = typename fl::Bool_t<(sizeof(typename std::remove_reference<T>::type) <= sizeof(void *))>::template
                And<std::is_scalar<typename std::remove_reference<T>::type>>::template
                conditional<typename std::remove_reference<T>::type, const T &>::type;

    namespace is {
        template<typename T>
        struct none : std::conditional<std::is_same<T, fl::none>::value, fl::true_type, fl::false_type>::type {};
        template<typename T>
        struct undefined : std::conditional<std::is_same<T, fl::undefined>::value, fl::true_type, fl::false_type>::type {};
    }

    namespace Attribute {
        namespace Has {
            namespace { // This namespace is there to hide the macro
            #define FL_CREATE_HAS_ATTRIBUTE(class_name, attribute)                                                              \
                template<typename T>                                                                                            \
                struct class_name##_helper {                                                                                    \
                private:                                                                                                        \
                    template <typename _t>                                                                                      \
                    static constexpr auto hasType(int) -> typename _t::attribute { return std::declval<_t::type>(); }           \
                    template <typename>                                                                                         \
                    static constexpr fl::undefined hasType(long) { return {}; }                                                 \
                    template <typename _t>                                                                                      \
                    static constexpr auto hasValue(int) -> decltype(_t::attribute)                                              \
                    { return _t::attribute; }                                                                                   \
                    template <typename>                                                                                         \
                    static constexpr fl::undefined hasValue(long) { return {}; }                                                \
                    template <bool, typename _tp>                                                                               \
                    struct getValue {                                                                                           \
                        static constexpr auto get() -> decltype(hasType<_tp>(0))                                                \
                        { return hasType<_tp>(0); }                                                                             \
                    };                                                                                                          \
                    template <typename _tp>                                                                                     \
                    struct getValue<false, _tp> {                                                                               \
                        static constexpr auto get() -> decltype(hasValue<_tp>(0))                                               \
                        { return hasValue<_tp>(0); }                                                                            \
                    };                                                                                                          \
                public:                                                                                                         \
                    static constexpr bool isType = !std::is_same<fl::undefined, decltype(hasType<T>(0))>::value;                \
                    typedef typename std::conditional<isType, decltype(hasType<T>(0)), decltype(hasValue<T>(0))>::type type;    \
                    static constexpr bool value = !std::is_same<fl::undefined, type>::value;                                    \
                    static constexpr type atValue = getValue<isType, T>::get();                                                 \
                };                                                                                                              \
                template<typename T>                                                                                            \
                struct [[maybe_unused]] class_name : fl::Bool_t<class_name##_helper<T>::value> {                                  \
                private:                                                                                                        \
                    struct redirected_value {                                                                                   \
                        static constexpr auto value = class_name##_helper<T>::atValue;                                          \
                    };                                                                                                          \
                public:                                                                                                         \
                    struct [[maybe_unused]] Attribute : std::conditional<                                                       \
                        class_name##_helper<T>::isType,                                                                         \
                        redirect<typename class_name##_helper<T>::type>,                                                        \
                        typename std::conditional<                                                                              \
                            class_name::value,                                                                                  \
                            redirect_value<redirected_value>,                                                                   \
                            undefined                                                                                           \
                    >::type>::type {                                                                                            \
                        [[maybe_unused]] static constexpr bool isType = class_name##_helper<T>::isType;                         \
                        [[maybe_unused]] static constexpr bool isValue = class_name::value && !isType;                          \
                    };                                                                                                          \
                }
            }

            FL_CREATE_HAS_ATTRIBUTE(Type, type);
            FL_CREATE_HAS_ATTRIBUTE(Value, value);
        }

        template <typename T, typename _default=none>
        struct [[maybe_unused]] safeType :
        Attribute::Has::Type<T>::template And_b<Attribute::Has::Type<T>::Attribute::isType>::template conditional<
            redirect_type <typename Attribute::Has::Type<T>::Attribute>,
            typename is::none<_default>::template conditional<
                undefined,
                redirect<_default>
            >::type
        >::type {};
        template <typename T, typename _default=none>
        using safeType_t = typename safeType<T, _default>::type;

        template <typename T, typename _default_type=none,
            typename is::none<_default_type>::template conditional<int, _default_type>::type _default_value=0>
        struct [[maybe_unused]] safeValue :
        Attribute::Has::Value<T>::template And_b<Attribute::Has::Value<T>::Attribute::isType>::template conditional<
            redirect_value <typename Attribute::Has::Value<T>::Attribute>,
            typename is::none<_default_type>::template conditional<
                undefined,
                redirect_value<std::integral_constant<_default_type, _default_value>>
            >::type
        >::type {};
        template <typename T>
        using safeValue_t = typename safeValue<T>::value;
    }
    namespace Operator { // the operator
        namespace Has {
            namespace { // This namespace is there to hide the macros
            #define FL_CREATE_HAS_OPERATOR_2ARGS(class_name, operator)                                              \
                template <typename T1, typename T2=T1>                                                              \
                struct class_name##_helper                                                                          \
                {                                                                                                   \
                private:                                                                                            \
                    template <typename _t1, typename _t2>                                                           \
                    static auto has(_t1&& a1, _t2&& a2, int) -> decltype(a1 operator a2) { return a1 operator a2; } \
                    template <typename _t1, typename _t2>                                                           \
                    static fl::undefined has(_t1&&, _t2&&, long) { return {}; }                                     \
                public:                                                                                             \
                    typedef decltype(has(std::declval<T1>(), std::declval<T2>(), 0)) type;                          \
                    static constexpr bool value = !fl::is::undefined<type>::value;                                  \
                };                                                                                                  \
                template <typename T1, typename T2=T1>                                                              \
                struct [[maybe_unused]] class_name : std::conditional<                                              \
                    class_name##_helper<T1, T2>::value,                                                             \
                    redirect_type<class_name##_helper<T1, T2>>,                                                     \
                    undefined                                                                                       \
                >::type, fl::Bool_t<class_name##_helper<T1, T2>::value> {};                                           \
                template <typename T1, typename T2=T1>                                                              \
                using class_name##_t = typename class_name<T1, T2>::type

            #define FL_CREATE_HAS_OPERATOR_1ARGS(class_name, operator)                                              \
                template <typename T>                                                                               \
                struct class_name##_helper                                                                          \
                {                                                                                                   \
                private:                                                                                            \
                    template <typename _t>                                                                          \
                    static auto has(_t&& a, int) -> decltype(operator a) { return operator a; }                     \
                    template <typename _t>                                                                          \
                    static fl::undefined has(_t&&, long) { return {}; }                                             \
                public:                                                                                             \
                    typedef decltype(has(std::declval<T>(), 0)) type;                                               \
                    static constexpr bool value = !fl::is::undefined<type>::value;                                  \
                };                                                                                                  \
                template <typename T>                                                                               \
                struct [[maybe_unused]] class_name : std::conditional<                                              \
                    class_name##_helper<T>::value,                                                                  \
                    redirect<class_name##_helper<T>>,                                                               \
                    undefined                                                                                       \
                >::type, fl::Bool_t<class_name##_helper<T>::value> {};                                                \
                template <typename T>                                                                               \
                using class_name##_t = typename class_name<T>::type
            }
            namespace bitwise {
                FL_CREATE_HAS_OPERATOR_1ARGS(Invert, ~);

                FL_CREATE_HAS_OPERATOR_2ARGS(Add, &);
                FL_CREATE_HAS_OPERATOR_2ARGS(Xor, ^);
                FL_CREATE_HAS_OPERATOR_2ARGS(Or, |);
                FL_CREATE_HAS_OPERATOR_2ARGS(ShiftLeft, <<);
                FL_CREATE_HAS_OPERATOR_2ARGS(ShiftRight, >>);

                namespace assign {
                    FL_CREATE_HAS_OPERATOR_2ARGS(Add, &=);
                    FL_CREATE_HAS_OPERATOR_2ARGS(Xor, ^=);
                    FL_CREATE_HAS_OPERATOR_2ARGS(Or, |=);
                    FL_CREATE_HAS_OPERATOR_2ARGS(ShiftLeft, <<=);
                    FL_CREATE_HAS_OPERATOR_2ARGS(ShiftRight, >>=);
                }
            }

            FL_CREATE_HAS_OPERATOR_1ARGS(Positive, +);
            FL_CREATE_HAS_OPERATOR_1ARGS(Negative, -);
            FL_CREATE_HAS_OPERATOR_1ARGS(Increment, ++);
            FL_CREATE_HAS_OPERATOR_1ARGS(Decrement, --);

            FL_CREATE_HAS_OPERATOR_1ARGS(Address, &);
            FL_CREATE_HAS_OPERATOR_1ARGS(Dereference, *);

            FL_CREATE_HAS_OPERATOR_2ARGS(Add, +);
            FL_CREATE_HAS_OPERATOR_2ARGS(Sub, -);
            FL_CREATE_HAS_OPERATOR_2ARGS(Mul, *);
            FL_CREATE_HAS_OPERATOR_2ARGS(Div, /);
            FL_CREATE_HAS_OPERATOR_2ARGS(Mod, %);

            FL_CREATE_HAS_OPERATOR_2ARGS(Assign, =);

            namespace assign {
                FL_CREATE_HAS_OPERATOR_2ARGS(Add, +=);
                FL_CREATE_HAS_OPERATOR_2ARGS(Sub, -=);
                FL_CREATE_HAS_OPERATOR_2ARGS(Mul, *=);
                FL_CREATE_HAS_OPERATOR_2ARGS(Div, /=);
                FL_CREATE_HAS_OPERATOR_2ARGS(Mod, %=);
            }

            FL_CREATE_HAS_OPERATOR_2ARGS(Smaller, <);
            FL_CREATE_HAS_OPERATOR_2ARGS(Bigger, >);
            FL_CREATE_HAS_OPERATOR_2ARGS(SmallerEqual, <=);
            FL_CREATE_HAS_OPERATOR_2ARGS(BiggerEqual, >=);
            FL_CREATE_HAS_OPERATOR_2ARGS(Equal, ==);
            FL_CREATE_HAS_OPERATOR_2ARGS(NotEqual, !=);

            #if __cplusplus >= 202002L // For the future C++ 20
                FL_CREATE_HAS_OPERATOR_2ARGS(Comparison, <=>);
            #endif

            FL_CREATE_HAS_OPERATOR_2ARGS(And, &&);
            FL_CREATE_HAS_OPERATOR_2ARGS(Or, ||);
            FL_CREATE_HAS_OPERATOR_1ARGS(Not, !);

            // operator ->
            template <typename T>
            struct Arrow_helper
            {
            private:
                template <typename _t>
                static auto has(_t&& a, int) -> decltype(a.operator->()) { return a.operator->(); }
                template <typename _t>
                static fl::undefined has(_t&&, long) { return {}; }
            public:
                typedef decltype(has(std::declval<T>(), 0)) type;
                static constexpr bool value = std::is_pointer<T>::value || !fl::is::undefined<type>::value;
            };
            template <typename T>
            struct [[maybe_unused]] Arrow : std::conditional<
                Arrow_helper<T>::value,
                redirect_type<Arrow_helper<T>>,
                undefined
            >::type, fl::Bool_t<Arrow_helper<T>::value> {};
            template <typename T>
            using Arrow_t = typename Arrow<T>::type;

            // operator [T2]
            template <typename T1, typename T2=int>
            struct Bracket_helper
            {
            private:
                template <typename _t1, typename _t2>
                static auto has(_t1&& a1, _t2&& a2, int) -> decltype(a1[a2]) { return a1[a2]; }
                template <typename _t1, typename _t2>
                static fl::undefined has(_t1&&, _t2&&, long) { return {}; }
            public:
                typedef decltype(has(std::declval<T1>(), std::declval<T2>(), 0)) type;
                static constexpr bool value = !fl::is::undefined<type>::value;
            };
            template <typename T1, typename T2=int>
            struct [[maybe_unused]] Bracket : std::conditional<
                Bracket_helper<T1, T2>::value,
                redirect_type<Bracket_helper<T1, T2>>,
                undefined
            >::type, fl::Bool_t<Bracket_helper<T1, T2>::value> {};
            template <typename T1, typename T2=int>
            using Bracket_t = typename Bracket<T1, T2>::type;

            // operator (Ts...)
            template <typename T, typename ...Ts>
            struct Parenthesis_helper
            {
            private:
                template <typename _t, typename ..._ts>
                static auto _has(_t&& f, _ts&&... args, int) -> decltype(f(args...)) { return f(args...); }
                template <typename _t, typename ..._ts>
                static fl::undefined _has(_t&&, _ts&&..., long) { return {}; }

            #if  __cplusplus >= 201703L // if (current_version >= C++17)
                template <typename _t, typename ..._ts>
                static auto hasOperator(int) -> redirect<typename std::invoke_result<_t, _ts...>::type>
                { return {}; }
            #else
                template <typename _t, typename ..._ts>
                static auto hasOperator(int) -> redirect<typename std::result_of<_t(_ts...)>::type>
                { return {}; }
            #endif
                template <typename, typename ...>
                static redirect<undefined> hasOperator(long)
                { return {}; }
            public:
                typedef typename decltype(hasOperator<T, Ts...>(0))::type type;
                static constexpr bool value = !fl::is::undefined<type>::value;
            };
            template <typename T, typename ...Ts>
            struct [[maybe_unused]] Parenthesis : std::conditional<
                Parenthesis_helper<T, Ts...>::value,
                redirect<Parenthesis_helper<T, Ts...>>,
                undefined
            >::type, fl::Bool_t<Parenthesis_helper<T, Ts...>::value> {};
            template <typename T, typename ...Ts>
            using Parenthesis_t = typename Parenthesis<T, Ts...>::type;

            // operator To(T)
            template <typename T, typename _to>
            struct To_helper
            {
            private:
                template <typename _t>
                static auto has(_t&& a, int) -> decltype(_to(a)) { return _to(a); }
                template <typename _t>
                static fl::undefined has(_t&&, long) { return {}; }
            public:
                typedef decltype(has(std::declval<T>(), 0)) type;
                static constexpr bool value = !fl::is::undefined<type>::value;
            };
            template <typename T, typename _to>
            struct [[maybe_unused]] To : std::conditional<
                To_helper<T, _to>::value,
                redirect<To_helper<T, _to>>,
                undefined
            >::type, fl::Bool_t<To_helper<T, _to>::value> {};
            template <typename T, typename _to>
            using To_t = typename To<T, _to>::type;

            // operator bool(T)
            template <typename T>
            using To_bool = To<T, bool>;
            template <typename T>
            using To_bool_t = typename To<T, bool>::type;

        #if  __cplusplus >= 201703L // if (current_version >= C++17)
            namespace {
                namespace bitwise {
                    template <typename T> [[maybe_unused]] constexpr inline bool Invert_v = fl::Operator::Has::bitwise::Invert<T>::value;

                    template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Add_v = fl::Operator::Has::bitwise::Add<T1, T2>::value;
                    template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Xor_v = fl::Operator::Has::bitwise::Xor<T1, T2>::value;
                    template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Or_v = fl::Operator::Has::bitwise::Or<T1, T2>::value;
                    template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool ShiftLeft_v = fl::Operator::Has::bitwise::ShiftLeft<T1, T2>::value;
                    template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool ShiftRight_v = fl::Operator::Has::bitwise::ShiftRight<T1, T2>::value;

                    namespace assign {
                        template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Add_v = fl::Operator::Has::bitwise::assign::Add<T1, T2>::value;
                        template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Xor_v = fl::Operator::Has::bitwise::assign::Xor<T1, T2>::value;
                        template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Or_v = fl::Operator::Has::bitwise::assign::Or<T1, T2>::value;
                        template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool ShiftLeft_v = fl::Operator::Has::bitwise::assign::ShiftLeft<T1, T2>::value;
                        template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool ShiftRight_v = fl::Operator::Has::bitwise::assign::ShiftRight<T1, T2>::value;
                    }
                }

                template <typename T> [[maybe_unused]] constexpr inline bool Positive_v = fl::Operator::Has::Positive<T>::value;
                template <typename T> [[maybe_unused]] constexpr inline bool Negative_v = fl::Operator::Has::Negative<T>::value;
                template <typename T> [[maybe_unused]] constexpr inline bool Increment_v = fl::Operator::Has::Increment<T>::value;
                template <typename T> [[maybe_unused]] constexpr inline bool Decrement_v = fl::Operator::Has::Decrement<T>::value;

                template <typename T> [[maybe_unused]] constexpr inline bool Address_v = fl::Operator::Has::Address<T>::value;
                template <typename T> [[maybe_unused]] constexpr inline bool Dereference_v = fl::Operator::Has::Dereference<T>::value;

                template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Add_v = fl::Operator::Has::Add<T1, T2>::value;
                template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Sub_v = fl::Operator::Has::Sub<T1, T2>::value;
                template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Mul_v = fl::Operator::Has::Mul<T1, T2>::value;
                template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Div_v = fl::Operator::Has::Div<T1, T2>::value;
                template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Mod_v = fl::Operator::Has::Mod<T1, T2>::value;

                template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Assign_v = fl::Operator::Has::Assign<T1, T2>::value;

                namespace assign {
                    template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Add_v = fl::Operator::Has::assign::Add<T1, T2>::value;
                    template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Sub_v = fl::Operator::Has::assign::Sub<T1, T2>::value;
                    template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Mul_v = fl::Operator::Has::assign::Mul<T1, T2>::value;
                    template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Div_v = fl::Operator::Has::assign::Div<T1, T2>::value;
                    template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Mod_v = fl::Operator::Has::assign::Mod<T1, T2>::value;
                }

                template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool And_v = fl::Operator::Has::And<T1, T2>::value;
                template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Or_v = fl::Operator::Has::Or<T1, T2>::value;
                template <typename T> [[maybe_unused]] constexpr inline bool Not_v = fl::Operator::Has::Not<T>::value;

                template <typename T> [[maybe_unused]] constexpr inline bool Arrow_v = fl::Operator::Has::Arrow<T>::value;
                template <typename T1, typename T2=T1> [[maybe_unused]] constexpr inline bool Bracket_v = fl::Operator::Has::Bracket<T1, T2>::value;
                template <typename T, typename ...Ts> [[maybe_unused]] constexpr inline bool Parenthesis_v = fl::Operator::Has::Parenthesis<T, Ts...>::value;

                template <typename T1, typename T2> [[maybe_unused]] constexpr inline bool To_v = fl::Operator::Has::To<T1, T2>::value;
                template <typename T> [[maybe_unused]] constexpr inline bool ToBool_v = fl::Operator::Has::To_bool<T>::value;
            }
        #endif

        #undef FL_CREATE_HAS_OPERATOR_2ARGS
        #undef FL_CREATE_HAS_OPERATOR_1ARGS
        }
        namespace Apply { /* In dev */}
    }

    namespace noerror {
        /// Call a function if possible
        template<typename F, typename ...Ts, typename std::enable_if<fl::Operator::Has::Parenthesis<F, Ts...>::value, int>::type=0>
        [[maybe_unused]] constexpr auto call(F &&function, Ts&&... all) -> decltype(function(all...))
        { return function(all...); }
        template<typename F, typename ...Ts, typename std::enable_if<!fl::Operator::Has::Parenthesis<F, Ts...>::value, int>::type=0>
        [[maybe_unused]] constexpr void call(F &&, Ts&&...) { }


        /// Print the data is possible
        template<typename T>
        [[maybe_unused]] static auto print(T &&obj) -> decltype(std::cout << obj)
        { return std::cout << obj; }

        template<typename Stream, typename T>
        [[maybe_unused]] static auto print(Stream& os, T&& obj) -> decltype( os << obj )
        { return os << obj; }

        [[maybe_unused]] static std::ostream &print(...)
        { return std::cout; }

    }
    namespace tuple {
        /// [get] extract template from specialized class
        /// \tparam idx (index to extract the template)
        /// \tparam tuple (class to extract the template)
        template <size_t idx, typename tuple, typename _default=none>
        struct [[maybe_unused]] get : fl::is::none<_default>::template conditional<undefined, redirect<_default>>::type {};
        template <size_t idx, template <typename ...> class tuple, typename T, typename ...Ts, typename _default>
        struct [[maybe_unused]] get<idx, tuple<T, Ts...>, _default> : get<idx - 1, std::tuple<Ts...>, _default> {};
        template <template <typename ...> class tuple, typename T, typename ...Ts, typename _default>
        struct [[maybe_unused]] get<0, tuple<T, Ts...>, _default> : redirect<T> {};
        template <size_t idx, class tuple, typename _default=none>
        using get_t = typename get<idx, tuple, _default>::type;

        /// Remove the last template of a tuple
        /// \tparam T is a tuple
        template <typename T>
        struct [[maybe_unused]] removeLast {};
        template <typename T>
        struct [[maybe_unused]] removeLast<std::tuple<T>> : redirect<std::tuple<>> {};
        template <typename T, typename ...Args>
        struct [[maybe_unused]] removeLast<std::tuple<T, Args...>> : redirect<
                decltype(std::tuple_cat(
                        std::declval<std::tuple<T>>(),
                        std::declval<typename removeLast<std::tuple<Args...>>::type>()
                ))
        > {};

        /// Create tuple with the type of the are of a function T(Ts...) -> std::tuple<Ts...>
        /// \tparam T is a tuple
        template <typename T>
        struct [[maybe_unused]] from_arg {};
        template <typename T, typename ...Ts>
        struct [[maybe_unused]] from_arg<T(Ts...)> : redirect<std::tuple<Ts...>> {};
    }
    namespace variadic {
        /// [get] extract template from variadic template
        /// \tparam idx (index to extract the template)
        /// \tparam T + ...Ts (is the variadic template)
        template <size_t idx, class T, class ...Ts>
        struct [[maybe_unused]] get : get<idx - 1, Ts...> {};
        template <class T, class ...Ts>
        struct [[maybe_unused]] get<0, T, Ts...> : redirect<T> {};
        template <size_t idx, class T, class ...Ts>
        using get_t = typename get<idx, T, Ts...>::type;

#if __cplusplus >= 201402L // if (current_version >= C++14)
        template <size_t idx, typename T, typename ...Ts>
        [[maybe_unused]] constexpr auto get_args(T&& value, Ts&&... rest)
        -> typename std::enable_if<idx <= sizeof...(Ts), typename get<idx, T, Ts...>::type &>::type
        {
#if  __cplusplus >= 201703L // if (current_version >= C++17)
            if constexpr (idx == 0) {
                return (T&)value;
            } else {
                return get_args<idx - 1>(rest...);
            }
#else
            // Todo, fix it for C++ < 17
        return fl::Bool_t<idx == 0>::func_else(
            [ &value ] (Ts&&...) -> T& { return value; },
            [] (Ts&&... args) { return get_args<idx - 1>(args...); },
        rest...);
#endif
        }
#endif
    }

    namespace dclSt {
        // toAny
        template <typename T1, typename T2=void, typename ...Ts>
        struct toAny : toAny<T2, Ts...> {};
        template <typename T1, typename T2>
        struct toAny<T1, T2> : redirect<T2> {};


        namespace {
            // select
            template <typename>
            struct [[maybe_unused]] _is_case : fl::false_type {};
            template <typename T, typename ...Ts>
            struct [[maybe_unused]] _is_case<T(Ts...)> : fl::true_type {};

            template <typename>
            struct [[maybe_unused]] _case_result : redirect<undefined> {};
            template <typename T, typename ...Ts>
            struct [[maybe_unused]] _case_result<T(Ts...)> : redirect<T> {};

            template <typename, typename>
            struct [[maybe_unused]] _is_case_match : fl::false_type {};
            template <typename T, typename ...Ts>
            struct [[maybe_unused]] _is_case_match<std::tuple<Ts...>, T(Ts...)> : fl::true_type {};

            template <typename, typename>
            struct [[maybe_unused]] _select_body {};
            template <typename ...input, typename T, typename ...Ts>
            struct [[maybe_unused]] _select_body<std::tuple<input...>, std::tuple<T, Ts...>>
                    : _select_body<std::tuple<input...>, std::tuple<Ts...>> {};
            template <typename ...input, typename result, typename T, typename ...Ts>
            struct [[maybe_unused]] _select_body<std::tuple<input...>, std::tuple<result(input...), T, Ts...>>
                    : redirect<result> {};
            template <typename ...input, typename last>
            struct [[maybe_unused]] _select_body<std::tuple<input...>, std::tuple<last>>
                    : _is_case<last>::template conditional<
                            typename _is_case_match<std::tuple<input...>, last>::template conditional<
                                    redirect<typename _case_result<last>::type>,
                                    redirect<undefined>
                            >::type,
                            redirect<last>
                    >::type {};

            template <typename>
            struct [[maybe_unused]] _select_head {};
            template <typename ...input>
            struct [[maybe_unused]] _select_head<std::tuple<input...>> {
                template <typename ...Ts>
                using cases = typename _select_body<std::tuple<input...>, std::tuple<Ts...>>::type;
            };
        }
    }
    namespace dclTp {
        template <typename T, typename ...Ts>
        using toAny = typename fl::dclSt::toAny<T, Ts...>::type;

        template <typename ...input>
        using select = fl::dclSt::_select_head<std::tuple<input...>>;
    }

    namespace is {
        /// return<bool _type> ex: <typeof(std::vector<Ts...>(1)), std::vector>::value return true because the value is a specialization of std::vector
        template<typename, template<typename ...> class>
        struct [[maybe_unused]] specialization : fl::false_type {};
        template<template<typename ...> class Ref, typename ...Ts>
        struct [[maybe_unused]] specialization<Ref<Ts...>, Ref> : fl::true_type {};

        template <typename, typename=void>
        struct [[maybe_unused]] iterable : fl::false_type {
            struct Attribute {
                [[maybe_unused]] static constexpr size_t depth = 0;
            };
        };

        template <typename T>
        struct [[maybe_unused]] iterable<T,
            std::void_t<
                decltype(std::begin(std::declval<T&>()) != std::end(std::declval<T&>())),
                decltype(++std::declval<decltype(std::begin(std::declval<T&>()))&>()),
                decltype(*std::begin(std::declval<T&>()))
            >
        > : fl::true_type, redirect<decltype(*std::begin(std::declval<T&>()))> {
            struct Attribute {
                struct next : iterable<decltype(*std::begin(std::declval<T&>()))> {};
                [[maybe_unused]] static constexpr size_t depth = 1 + next::Attribute::depth;
            };
        };
        template <typename T>
        using iterable_t = typename iterable<T>::type;

        /// return<bool> if x{as a '*x'} is null return true else return false
        template <typename T, typename std::enable_if<fl::Operator::Has::Equal<T, std::nullptr_t>::value, int>::type=0>
        [[maybe_unused]] bool null(T&&x) { return x == nullptr; }
        template <typename T, typename std::enable_if<!fl::Operator::Has::Equal<T, std::nullptr_t>::value, int>::type=0>
        [[maybe_unused]] bool null(T&&) { return false; }


        // Todo
        // printable
    #if  __cplusplus >= 201703L // if (current_version >= C++17)
        template <typename T> [[maybe_unused]] inline static constexpr bool none_v = none<T>::value;
        template <typename T> [[maybe_unused]] inline static constexpr bool undefined_v = undefined<T>::value;
        template <typename T, template<typename...> class Ref> [[maybe_unused]] inline static constexpr bool specialization_v = specialization<T, Ref>::value;
        template <typename T> [[maybe_unused]] inline static constexpr bool iterable_v = iterable<T>::value;
    #endif
    }

    namespace /* _ */ {
        ///this function allow to try to dereference any data without ever failing if it can't it return the data it self

        /// nothing
        [[maybe_unused]] void _() { }
        /// return<*x> if x can '*x' else return<x> 'as default'
         template <typename T>
        [[maybe_unused]] constexpr auto _(T &&x)
            -> typename Operator::Has::Dereference<T>::template enable_if<decltype(*x)>::type
        { return *x; }
        template <typename T>
        [[maybe_unused]] constexpr auto _(T &&x)
            -> typename Operator::Has::Dereference<T>::Not::template
            And<Operator::Has::Bracket<T>>::template
            enable_if<decltype(x[0])>::type
        { return x[0]; }
        template <typename T>
        [[maybe_unused]] constexpr auto _(T &&x)
            -> typename Operator::Has::Dereference<T>::Not::template
            And<typename Operator::Has::Bracket<T>::Not>::template
            enable_if<T&>::type
        { return x; }

        /// return<x[idx]> if x can 'x[idx]' else return<x>
        template <typename T, typename indexType>
        [[maybe_unused]] constexpr auto _(T &&x, indexType idx)
            -> typename Operator::Has::Bracket<T, indexType>::template
            And<std::is_same<bTp<indexType>, indexType>>::template
            enable_if<decltype(x[idx])>::type
        { return x[idx]; }

        template <typename T, typename indexType>
        [[maybe_unused]] constexpr auto _(T &&x, indexType idx)
            -> typename Operator::Has::Bracket<T, indexType>::template
            And<std::is_same<bTp<indexType>, const indexType &>>::template
            enable_if<decltype(x[idx])>::type
        { return x[idx]; }

        template <typename T, typename indexType>
        [[maybe_unused]] constexpr auto _(T &&x, indexType&&)
            -> typename Operator::Has::Bracket<T, indexType>::Not::template enable_if<T&>::type
        { return x; }
    }

    template <typename ...input>
    using select = dclTp::select<input...>;
}

namespace fl_dev {
    namespace dclTp {

    }
    namespace variadic {
        /* Todo
        template <typename lambda, typename ...Ts>
        auto next(lambda&& func, Ts... all) { return fl::Bool_t<(sizeof...(Ts) > 0)>::func(Next_templete_of_variadic<lambda, Ts...>, func, all...); };
        template <typename lambda, typename ...Ts>
        auto nextRef(lambda&& func, Ts&&... all) { return fl::Bool_t<(sizeof...(Ts) > 0)>::func(Next_templete_of_variadic_with_ref<lambda, Ts...>, func, all...); };
        */
    }
    namespace legacy {
        namespace dclSt {
            // _select
            /*
            template <typename input, typename T>
            struct [[maybe_unused]] _select {};
            template <typename input, template <typename ...> typename tuple, typename reference, typename result, typename ...Ts>
            struct [[maybe_unused]] _select<input, tuple<reference, result, Ts...>> : _select<input, std::tuple<Ts...>> {};
            template <typename input, template <typename ...> typename tuple, typename result, typename ...Ts>
            struct [[maybe_unused]] _select<input, tuple<input, result, Ts...>> : redirect<result> {};
            template <typename input, template <typename ...> typename tuple, typename last>
            struct [[maybe_unused]] _select<input, tuple<last>> : redirect<last> {};
            */


            // select
            /*
            template <typename, typename>
            struct select_case {};

            template <typename ...input, typename ...reference, typename result, typename ...Ts>
            struct select_case<std::tuple<input...>, std::tuple<std::tuple<reference...>, result, Ts...>>
                : select_case<std::tuple<input...>, std::tuple<Ts...>> {};

            template <typename ...input, typename result, typename ...Ts>
            struct select_case<std::tuple<input...>, std::tuple<std::tuple<input...>, result, Ts...>> {
                typedef result type;
            };

            template <typename ...input, typename last>
            struct select_case<std::tuple<input...>, std::tuple<last>> {
                typedef last type;
            };

            template <typename, typename, typename>
            struct select_body;

            template <typename ...input, typename ...past, typename T, typename ...Ts> // Default nothing fund
            struct select_body<std::tuple<input...>, std::tuple<past...>, T(Ts...)> {

                template <typename _t=none>
                using c = select_body<std::tuple<input...>, std::tuple<past..., T(Ts...)>, _t>;
            };

            template <typename ...input, typename ...past, typename T>
            struct select_body<std::tuple<input...>, std::tuple<past...>, T(input...)> {

                template <typename _t=none>
                using c = select_body<std::tuple<input...>, std::tuple<past..., T(Ts...)>, _t>;
            };

            template <typename ...input, typename ...past, typename T> // End to the tail, will return T
            struct select_body<std::tuple<input...>, std::tuple<past...>, T> {
                typedef T type;
            };

            template <typename ...input, typename ...past> // End to the tail, will fail
            struct select_body<std::tuple<input...>, std::tuple<past...>, none> {}; // this one may be useless

            template <typename ...Ts>
            struct select_head {
                template <typename ..._ts>
                using cc = cc1<std::tuple<Ts...>, _ts...>;
            };
            */
        }
    }
    namespace Apply {
        /*
        template<typename A, typename B>
        static constexpr auto set(A &&a, B &&b) -> decltype(a = b) { return a = b; }

        template<typename A, typename ...B>
        static constexpr A &set(A &&a, B &&...) { return a; }

        template<typename A, typename B>
        static constexpr auto add(A &&a, B &&b) -> decltype(a + b) { return a + b; }

        template<typename A, typename ...B>
        static constexpr A &add(A &&a, B &&...) { return a; }

        template<typename A, typename B>
        static constexpr auto sub(A &&a, B &&b) -> decltype(a - b) { return a - b; }

        template<typename A, typename ...B>
        static constexpr A &sub(A &&a, B &&...) { return a; }
         */
    }
}


#endif //FLLIB_FL_H